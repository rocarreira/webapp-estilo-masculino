// Generated by Lasy AI - https://lasy.ai
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;

export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
    flowType: 'pkce'
  }
});

// Helper functions for common operations
export const auth = {
  signUp: async (email: string, password: string, metadata?: any) => {
    return await supabase.auth.signUp({
      email,
      password,
      options: {
        data: metadata,
        emailRedirectTo: `${typeof window !== 'undefined' ? window.location.origin : ''}/auth/callback`
      }
    });
  },

  signIn: async (email: string, password: string) => {
    return await supabase.auth.signInWithPassword({
      email,
      password
    });
  },

  signInWithOAuth: async (provider: 'google' | 'facebook' | 'apple') => {
    return await supabase.auth.signInWithOAuth({
      provider,
      options: {
        redirectTo: `${typeof window !== 'undefined' ? window.location.origin : ''}/auth/callback`
      }
    });
  },

  signOut: async () => {
    return await supabase.auth.signOut();
  },

  getSession: async () => {
    return await supabase.auth.getSession();
  },

  getUser: async () => {
    return await supabase.auth.getUser();
  },

  onAuthStateChange: (callback: (event: string, session: any) => void) => {
    return supabase.auth.onAuthStateChange(callback);
  }
};

// Database helpers
export const db = {
  // Users
  getUser: async (userId: string) => {
    return await supabase
      .from('users')
      .select('*')
      .eq('id', userId)
      .single();
  },

  updateUser: async (userId: string, data: any) => {
    return await supabase
      .from('users')
      .update(data)
      .eq('id', userId);
  },

  // Try-On History
  getTryOnHistory: async (userId: string, limit = 20) => {
    return await supabase
      .from('try_on_history')
      .select('*, beard_styles(*), hair_styles(*)')
      .eq('user_id', userId)
      .order('created_at', { ascending: false })
      .limit(limit);
  },

  saveTryOn: async (data: any) => {
    return await supabase
      .from('try_on_history')
      .insert(data);
  },

  // Routine
  getUserRoutines: async (userId: string) => {
    return await supabase
      .from('user_routines')
      .select('*, routine_tasks(*)')
      .eq('user_id', userId)
      .order('created_at', { ascending: false });
  },

  completeRoutineTask: async (routineId: string) => {
    return await supabase
      .from('user_routines')
      .update({
        completed: true,
        completed_at: new Date().toISOString()
      })
      .eq('id', routineId);
  },

  // Social Feed
  getFeedPosts: async (limit = 20, offset = 0) => {
    return await supabase
      .from('posts')
      .select('*, users(*), likes(count), comments(count)')
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1);
  },

  createPost: async (data: any) => {
    return await supabase
      .from('posts')
      .insert(data);
  },

  likePost: async (postId: string, userId: string) => {
    return await supabase
      .from('likes')
      .insert({ post_id: postId, user_id: userId });
  },

  unlikePost: async (postId: string, userId: string) => {
    return await supabase
      .from('likes')
      .delete()
      .eq('post_id', postId)
      .eq('user_id', userId);
  },

  // Badges & Gamification
  getUserBadges: async (userId: string) => {
    return await supabase
      .from('user_badges')
      .select('*, badges(*)')
      .eq('user_id', userId)
      .order('earned_at', { ascending: false });
  },

  awardBadge: async (userId: string, badgeId: string) => {
    return await supabase
      .from('user_badges')
      .insert({ user_id: userId, badge_id: badgeId });
  },

  // Rankings
  getRankings: async (category: string, period: string, limit = 50) => {
    return await supabase
      .from('rankings')
      .select('*, users(*)')
      .eq('category', category)
      .eq('period', period)
      .order('rank', { ascending: true })
      .limit(limit);
  }
};

// Storage helpers
export const storage = {
  uploadAvatar: async (userId: string, file: File) => {
    const fileExt = file.name.split('.').pop();
    const fileName = `${userId}-${Date.now()}.${fileExt}`;
    const filePath = `avatars/${fileName}`;

    const { data, error } = await supabase.storage
      .from('avatars')
      .upload(filePath, file);

    if (error) throw error;

    const { data: { publicUrl } } = supabase.storage
      .from('avatars')
      .getPublicUrl(filePath);

    return publicUrl;
  },

  uploadTryOnImage: async (userId: string, file: File) => {
    const fileExt = file.name.split('.').pop();
    const fileName = `${userId}-${Date.now()}.${fileExt}`;
    const filePath = `try-ons/${fileName}`;

    const { data, error } = await supabase.storage
      .from('try-ons')
      .upload(filePath, file);

    if (error) throw error;

    const { data: { publicUrl } } = supabase.storage
      .from('try-ons')
      .getPublicUrl(filePath);

    return publicUrl;
  },

  uploadPostImage: async (userId: string, file: File) => {
    const fileExt = file.name.split('.').pop();
    const fileName = `${userId}-${Date.now()}.${fileExt}`;
    const filePath = `posts/${fileName}`;

    const { data, error } = await supabase.storage
      .from('posts')
      .upload(filePath, file);

    if (error) throw error;

    const { data: { publicUrl } } = supabase.storage
      .from('posts')
      .getPublicUrl(filePath);

    return publicUrl;
  },

  deleteFile: async (bucket: string, path: string) => {
    return await supabase.storage
      .from(bucket)
      .remove([path]);
  }
};

export default supabase;
